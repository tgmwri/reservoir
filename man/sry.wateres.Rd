% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/wateres.R
\name{sry}
\alias{sry}
\alias{sry.wateres}
\title{Calculation of storage, reliability and yield}
\usage{
sry(reser, storage, reliability, yield, prob_type, upper_limit, throw_exceed,
  get_series)

\method{sry}{wateres}(reser, storage, reliability, yield, prob_type = 7,
  upper_limit = 5, throw_exceed = FALSE, get_series = FALSE)
}
\arguments{
\item{reser}{A \code{wateres} object.}

\item{storage}{A water reservoir storage value in m3. (If missing together with reliability or yield, the default value
equal to the potential volume of \code{reser} will be used. If only storage is missing, it will be optimized using reliability
and yield.)}

\item{reliability}{A reliability value, cannot be less than zero or greater than maximum reliability value
(depending on data and probability type). Alternatively, \dQuote{max} value can be used to set reliability to its maximum
value. (If missing, reliability will be calculated using storage and yield.)}

\item{yield}{A required yield in m3.s-1, constant for all months. (If missing, it will be optimized using storage and reliability.)}

\item{prob_type}{Type of empirical probability used for calculation of reliability given as a number corresponding with the \code{type}
  argument of the \code{\link{quantile}} function or \dQuote{chegodayev} representing the (m - 0.3) / (n + 0.4) formula.
 For the numeric argument, currently only types 4 [m / n] and 7 [(m - 1) / (n - 1)] are supported.

 Therefore, maximum reliability value can be less than 1 for certain types.}

\item{upper_limit}{An upper limit for optimization of storage or yield given as multiple of potential volume of the reservoir
(for storage) or as multiple of mean monthly flow (for yield).}

\item{throw_exceed}{Whether volume exceeding storage will be thrown or added to yield. This will affect calculated yield series,
however resulting storage, reliability or yield value is not likely to be influenced.}

\item{get_series}{Whether time series of reservoir balance variables will be returned.}
}
\value{
A list consisting of:
  \item{storage}{storage value, optimized, equal to the \code{storage} argument or default (potential volume of \code{reser})}
  \item{reliability}{reliability value calculated for the given or optimized values of yield and storage}
  \item{yield}{yield value, optimized or equal to the \code{yield} argument}
  \item{series}{only if \code{get_series} is enabled, a list consisting of reservoir storage (m3), yield (m3.s-1), evaporation (m3)
    and withdrawal (m3) time series}
}
\description{
Calculates one of the water reservoir characteristics: storage, time-based reliability or yield (release) while the
two remaining values are provided.
}
\details{
If all the three values are provided, the reliability value will be ignored and it will be calculated for the provided
  storage and yield.

  To optimize the value of storage or yield, a simple bisection algorithm is applied. If the optimization fails because
  the required reliability is not contained within the provided interval, try to change its upper limit given as the \code{upper_limit}
  argument.

  As the required reliability represents a range of storage or yield values, the smallest value of storage (or the greatest value
  of yield) is returned, considering some tolerance value of the optimization algorithm.

  When optimizing the storage or yield value, a value which produces reliability closest to the required reliability is selected,
  hence the resulting reliability can be less or greater than the required one.

  If the calculated reliability is even for the zero storage value greater than the required reliability, the zero storage and
  the corresponding reliability will be returned. Contrary to this, if the calculated reliability is for the optimized yield greater,
  the optimization fails as the reliability can be decreased by increasing the upper limit.
}
\examples{
reser = data.frame(
    Q = c(0.078, 0.065, 0.168, 0.711, 0.154, 0.107, 0.068, 0.057, 0.07, 0.485, 0.252, 0.236,
          0.498, 0.248, 0.547, 0.197, 0.283, 0.191, 0.104, 0.067, 0.046, 0.161, 0.16, 0.094),
    DTM = seq(as.Date("2000-01-01"), by = "months", length.out = 24))
reser = as.wateres(reser, storage = 14.4e6, area = 754e3)
sry(reser, reliab = 0.9, yield = 0.14)
sry(reser, storage = 41e3, yield = 0.14)
sry(reser, yield = 0.14)
sry(reser, storage = 41e3, reliab = 0.5)
}

